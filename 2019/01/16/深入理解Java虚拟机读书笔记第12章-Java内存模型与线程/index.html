<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="线程,volatile,">










<meta name="description" content="计算机的运行速度是远远大于它的存储和通信子系统的速度。  基于⾼速缓存的存储交互很好地解决了处理器与内存的速度⽭盾，但 是也为计算机系统带来更⾼的复杂度，因为它引⼊了⼀个新的问题：缓存⼀致性（Cache Coherence）。在多处理器系统中，每个处理器都有⾃⼰的⾼速缓存，⽽它们又共享同⼀主内存（Main Memory） 当多个处理器的运算任务都涉及同⼀块主内存区域时，将可能导致各⾃的缓存数">
<meta name="keywords" content="线程,volatile">
<meta property="og:type" content="article">
<meta property="og:title" content="Java内存模型与线程">
<meta property="og:url" content="http://yoursite.com/2019/01/16/深入理解Java虚拟机读书笔记第12章-Java内存模型与线程/index.html">
<meta property="og:site_name" content="山有扶苏">
<meta property="og:description" content="计算机的运行速度是远远大于它的存储和通信子系统的速度。  基于⾼速缓存的存储交互很好地解决了处理器与内存的速度⽭盾，但 是也为计算机系统带来更⾼的复杂度，因为它引⼊了⼀个新的问题：缓存⼀致性（Cache Coherence）。在多处理器系统中，每个处理器都有⾃⼰的⾼速缓存，⽽它们又共享同⼀主内存（Main Memory） 当多个处理器的运算任务都涉及同⼀块主内存区域时，将可能导致各⾃的缓存数">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fz8hmlttgij30z60g4jwx.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNc79ly1fz8hqt95h2j313m0fogry.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79ly1fz8i1jnpjlj318g0hwtdr.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNc79ly1fz8i3yt6qhj317k0tm150.jpg">
<meta property="og:image" content="https://ws2.sinaimg.cn/large/006tNc79ly1fz8i547128j319w0doag4.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fz8ihefrqqj30zq0u01kx.jpg">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tNc79ly1fz8ks8p703j30cs082gmg.jpg">
<meta property="og:updated_time" content="2019-12-19T08:47:25.901Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java内存模型与线程">
<meta name="twitter:description" content="计算机的运行速度是远远大于它的存储和通信子系统的速度。  基于⾼速缓存的存储交互很好地解决了处理器与内存的速度⽭盾，但 是也为计算机系统带来更⾼的复杂度，因为它引⼊了⼀个新的问题：缓存⼀致性（Cache Coherence）。在多处理器系统中，每个处理器都有⾃⼰的⾼速缓存，⽽它们又共享同⼀主内存（Main Memory） 当多个处理器的运算任务都涉及同⼀块主内存区域时，将可能导致各⾃的缓存数">
<meta name="twitter:image" content="https://ws1.sinaimg.cn/large/006tNc79ly1fz8hmlttgij30z60g4jwx.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/16/深入理解Java虚拟机读书笔记第12章-Java内存模型与线程/">





  <title>Java内存模型与线程 | 山有扶苏</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">山有扶苏</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/深入理解Java虚拟机读书笔记第12章-Java内存模型与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="immrwk">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="山有扶苏">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java内存模型与线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T15:45:31+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <meta name="referrer" content="no-referrer">

<blockquote>
<p>计算机的运行速度是远远大于它的存储和通信子系统的速度。</p>
</blockquote>
<p>基于⾼速缓存的存储交互很好地解决了处理器与内存的速度⽭盾，但 是也为计算机系统带来更⾼的复杂度，因为它引⼊了⼀个新的问题：缓存⼀致性（Cache Coherence）。在多处理器系统中，每个处理器都有⾃⼰的⾼速缓存，⽽它们又共享同⼀主内存（Main Memory）</p>
<p>当多个处理器的运算任务都涉及同⼀块主内存区域时，将可能导致各⾃的缓存数据不⼀致，如果真的发⽣这种情况，那同步回到主内存时以谁的缓 存数据为准呢？为了解决⼀致性的问题，需要各个处理器访问缓存时都遵循⼀些协议，在读写时要根据协议来进⾏操作，这类协议有 MSI、 MESI（Illinois Protocol）、MOSI、Synapse、Firefly 及 Dragon Protocol 等。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fz8hmlttgij30z60g4jwx.jpg" alt></p>
<blockquote>
<p>内存模型：可以理解为在特定的「操作协议」下，对特定的「内存」或「⾼速缓存」进⾏「读写访问」的过程抽象。</p>
</blockquote>
<p>不同架构的物理机器可以拥有不⼀样的内存模型，⽽Java虚拟机也有⾃⼰的内存模型，并 且这⾥介绍的内存访问操作与硬件的缓存访问操作具有很⾼的可⽐性。</p>
<p>除了增加⾼速缓存之外，为了使得处理器内部的运算单元能尽量被充分利⽤，处理器可能会对输⼊代码「进⾏乱序执⾏（Out-Of-Order Execution）优化」，处理器会在计算之后将乱序执⾏的结果重组，保证该结果与顺序执⾏的结果是⼀致的，但并不保证程序中各个语句计算的先后顺序与输⼊代码中的顺序⼀致。</p>
<p>因此，如果存在⼀个计算任务依赖另外⼀个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执⾏优化类似，Java虚拟机的即时编译器中也有类似的「指令重排序」（Instruction Reorder）优化。</p>
<h1 id="1-Java-内存模型"><a href="#1-Java-内存模型" class="headerlink" title="1. Java 内存模型"></a><font color="#3FBA8B" size="6" face="黑体">1. Java 内存模型</font></h1><p>Java 虚拟机规范中试图定义一种「 Java 内存模型」（Java Memory Model，JMM），来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到⼀致的内存访问效果。主流程 序语⾔（如C/C++等）直接使⽤物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在⼀套平台上并发完全正常，⽽在另外⼀套平台上并发访问却经常出错，因此在某些场景就必须针对不同的平台来编写程序。</p>
<p>定义Java内存模型并⾮⼀件容易的事情，这个模型必须定义得⾜够严谨，才能让Java的并发内存访问操作不会产⽣歧义；但是，也必须定义得⾜够宽松，使得虚拟机的实现有⾜够的⾃由空间去利⽤硬件的各种特性 （寄存器、⾼速缓存和指令集中某些特有的指令）来获取更好的执⾏速度。</p>
<h2 id="1-1-主内存与工作内存"><a href="#1-1-主内存与工作内存" class="headerlink" title="1.1 主内存与工作内存"></a><font color="#3FBA8B" size="5" face="黑体">1.1 主内存与工作内存</font></h2><p>Java内存模型的「主要⽬标」是定义程序中「各个变量的访问规则」，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
<p>此处的变量（Variables）与J ava 编程中所说的变量有所区别，它包括了「实例字段」、「静态字段」和「构成数组对象的元素」，但不包括「局部变量」与「⽅法参数」，因为后者是线程私有的，不会被共享，⾃然就不会存在竞争问题。为了获得较好的执⾏效能，Java内存模型并没有限制执⾏引擎使⽤处理器的特定寄存 器或缓存来和主内存进⾏交互，也没有限制即时编译器进⾏调整代码执⾏顺序这类优化措施。</p>
<blockquote>
<p>如果局部变量是⼀个reference类型，它引用的对象在 Java 堆中可被各个线程共享，但是 reference 本身在Java栈的局部变量表中，它是线程私有的。</p>
</blockquote>
<p>JMM 规定了所有变量存储在「主内存」中（此处的主内存与介绍物理硬件时的主内存名字⼀样，两者也可以互相类⽐，但此处仅是虚拟机内存的⼀部分）。</p>
<p>每条线程还有⾃⼰的「⼯作内存」 （Working Memory，可与前⾯讲的处理器⾼速缓存类⽐），线程的⼯作内存中保存了被该线程使⽤到的变量的主内存副本拷贝。</p>
<p>线程对变量的所有操作（读取、赋值等）都必须在⼯作内存中进⾏，⽽不能直接读写主内存中的变量。不同的线程之间也⽆法直接访问对⽅⼯作内存中的变量， 线程间变量值的传递均需要通过主内存来完成。</p>
<blockquote>
<p>根据Java虚拟机规范的规定，volatile 变量依然有⼯作内存的拷贝，但是由于它特殊的操作顺序性规定（后⽂会讲到），所以看起来如同直接在主内存中读写访问⼀般，</p>
</blockquote>
<p>有可能会对工作内存“拷贝副本”提出疑问，如“假设线程中访问 ⼀个10MB的对象，也会把这10MB的内存复制⼀份拷贝出来吗？”，事实上并不会如此，这个对象的引用、对象中某个在线程访问到的字段是有可能存在拷贝的，但不会有虚拟机实现成把整个对象拷贝A⼀次。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz8hqt95h2j313m0fogry.jpg" alt></p>
<blockquote>
<p>这⾥所讲的「主内存、⼯作内存」与「Java内存区域」中的「Java堆、栈、⽅法区」等并不是同⼀个层次的内存划分，这两者基本上是没有关系的。如果两者⼀定要勉强对应起来，那从变量、主内存、⼯作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分 ，⽽⼯作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于「物理硬件的内存」，⽽为了获取更好的运⾏速度，虚拟机（甚⾄是硬件系统本⾝的优化措施）可能会让「⼯作内存」优先存储于寄存器和⾼速缓存中，因为程序运⾏时主要访问读写的是⼯作内存。</p>
</blockquote>
<p>除了实例数据，Java堆还保存了对象的其他信息，对于HotSpot虚拟机来 讲，有Mark Word（存储对象哈希码、GC标志、GC年龄、同步锁等信 息）、Klass Point（指向存储类型元数据的指针）及⼀些用于字节对齐补白的填充数据（如果实例数据刚好满⾜8字节对齐的话，则可以不存在补白）。</p>
<h2 id="1-2-内存间交互操作"><a href="#1-2-内存间交互操作" class="headerlink" title="1.2 内存间交互操作"></a><font color="#3FBA8B" size="5" face="黑体">1.2 内存间交互操作</font></h2><p>关于「主内存」与「⼯作内存」之间具体的「交互协议」，即⼀个变量如何从主内存拷贝到⼯作内存、如何从⼯作内存同步回主内存之类的实现细节，Java 内存模型中定义了以下 8 种操作来完成，虚拟机实现时必须保证下⾯提及的每⼀种操作都是原⼦的、不可再分的（对于double和long类型的变量来说， load、store、read和write操作在某些平台上允许有例外）。</p>
<ul>
<li>lock（锁定）：作⽤于主内存的变量，它把⼀个变量标识为⼀条线程独占的状态。</li>
<li>unlock（解锁）：作⽤于主内存的变量，它把⼀个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作⽤于主内存的变量，它把⼀个变量的值从主内存传输到线程的⼯作内存中，以便随后的 load 动作使⽤。</li>
<li>load（载⼊）：作⽤于⼯作内存的变量，它把read操作从主内存中得到的变量值放⼊⼯作内存的变量副本中。</li>
<li>use（使⽤）：作⽤于⼯作内存的变量，它把⼯作内存中⼀个变量的值传递给执⾏引擎，每当虚拟机遇到⼀个需要使⽤到变量的值的字节码指令时将会执⾏这个操作。</li>
<li>assign（赋值）：作⽤于⼯作内存的变量，它把⼀个从执⾏引擎接收到的值赋给⼯作内存的变量，每当虚拟机遇到⼀个给变量赋值的字节码指令时执⾏这个操作。</li>
<li>store（存储）：作⽤于⼯作内存的变量，它把⼯作内存中⼀个变量的值传送到主内存中，以便随后的write操作使⽤。</li>
<li>write（写⼊）：作⽤于主内存的变量，它把store操作从⼯作内存中得到的变量的值放⼊主内存的变量中。</li>
</ul>
<p>如果要把⼀个变量从「主内存复制到⼯作内存」，那就要顺序地执⾏ read 和 load 操作，如果要把变量「从⼯作内存同步回主内存」，就要顺序地执⾏ store 和 write 操作。注意，Java内存模型只要求上述两个操作必须按顺序执⾏，⽽没有保证是连续执⾏。</p>
<p>也就是说，read 与 load 之间、store 与 write 之间 是可插⼊其他指令的，如对主内存中的变量 a、b 进⾏访问时，⼀种可能出 现顺序是read a、read b、load b、load a。</p>
<p>除此之外，Java内存模型还规定了在执⾏上述 8 种基本操作时必须满⾜如下规则：</p>
<ul>
<li><p>不允许read和load、store和write操作之⼀单独出现，即不允许⼀个变量从主内存读取了但⼯作内存不接受，或者从⼯作内存发起回写了但主内存不接受的情况出现。</p>
</li>
<li><p>不允许⼀个线程丢弃它的最近的assign操作，即变量在⼯作内存中改变了之后必须把该变化同步回主内存。</p>
</li>
<li><p>不允许⼀个线程⽆原因地（没有发⽣过任何assign操作）把数据从线程的⼯作内存同步回主内存中。</p>
</li>
<li><p>⼀个新的变量只能在主内存中“诞⽣”，不允许在⼯作内存中直接使⽤⼀个未被初始化（load或assign）的变量，换句话说，就是对⼀个变量实施 use、store 操作之前，必须先执⾏过了assign和load操作。</p>
</li>
<li><p>⼀个变量在同⼀个时刻只允许⼀条线程对其进⾏ lock 操作，但 lock 操作可以被同⼀条线程重复执⾏多次，多次执⾏ lock 后，只有执⾏相同次数的 unlock 操作，变量才会被解锁。</p>
</li>
<li><p>如果对⼀个变量执⾏ lock 操作，那将会清空⼯作内存中此变量的值， 在执⾏引擎使⽤这个变量前，需要重新执⾏ load 或assign操作初始化变量的值。</p>
</li>
<li><p>如果⼀个变量事先没有被 lock 操作锁定，那就不允许对它执⾏ unlock 操作，也不允许去unlock⼀个被其他线程锁定住的变量。</p>
</li>
<li><p>对⼀个变量执⾏ unlock 操作之前，必须先把此变量同步回主内存中 （执⾏store、write操作）。</p>
</li>
</ul>
<p>这 8 种内存访问操作以及上述规则限定，再加上稍后介绍的对volatile的 ⼀些特殊规定，就已经完全确定了 Java 程序中哪些内存访问操作在并发下是安全的。不过这种定义严禁但麻烦，还有一个等效的判断原则「先行发生原则」，用来确定一个访问在并发环境是否安全。基于理解难度和严谨性考虑，JSR-133 ⽂档中，已经放弃采用这 8 种操作去定义 Java 内存模型的访问协议了（仅是描述⽅式改变了，Java 内存模型并没有改变）。</p>
<h2 id="1-3-对-volatile-型变量的特殊规则"><a href="#1-3-对-volatile-型变量的特殊规则" class="headerlink" title="1.3 对 volatile 型变量的特殊规则"></a><font color="#3FBA8B" size="5" face="黑体">1.3 对 volatile 型变量的特殊规则</font></h2><p>关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以⾄于许多程序员都习惯不去使⽤它，遇到需要处理多线程数据竞争问题的时候⼀律使⽤ synchronized 来进⾏同步。了解 volatile 变量的语义对后⾯了解多线程操作的其他特性很有意 义，在本节中我们将多花费⼀些时间去弄清楚volatile的语义到底是什么。</p>
<p>当⼀个变量定义为volatile之后，它将具备 2 种特性：</p>
<ol>
<li>保证此变量对所有线程的可见性，这⾥的“可见性”是指当⼀条线程修改了这个变量的值，新值对于其他线程来说是可以⽴即得知的。⽽普通变量不能做到这 ⼀点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A修改⼀个普通变量的值，然后向主内存进⾏回写，另外⼀条线程B在线程 A回写完成了之后再从主内存进⾏读取操作，新变量值才会对线程B可见。</li>
<li>使⽤volatile变量会禁⽌「指令重排序优化」，普通的变量仅仅会保证在该⽅法的执⾏过程中所有依赖赋值结果的地⽅都能获取到正确的结果，⽽不能保证变量赋值操作的顺序与程序代码中的执⾏顺序⼀致。 因为在⼀个线程的⽅法执⾏过程中⽆法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串⾏的语义”（Within-Thread As-If-Serial Semantics）。</li>
</ol>
<p>假定 T 表⽰⼀个线程，V 和 W 分别表⽰两个volatile型变量，那么在进⾏ read、load、use、assign、store 和 write 操作时需要满⾜如下规则：</p>
<ul>
<li><p>只有当线程 T 对变量V执⾏的前⼀个动作是load的时候，线程T才能对变量V执⾏ use 动作；并且，只有当线程T对变量V执⾏的后⼀个动作是 use 的时候，线程T才能对变量V执⾏load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续⼀起出现（这条规则要求在⼯作内存中，每次使⽤ V 前都必须先从主内存刷新最新的 值，⽤于保证能看见其他线程对变量V所做的修改后的值）。（即 load use read 连续出现）</p>
</li>
<li><p>只有当线程T对变量V执⾏的前⼀个动作是assign的时候，线程T才能对 变量V执⾏ store 动作；并且，只有当线程T对变量V执⾏的后⼀个动作是 store 的时候，线程T才能对变量V执⾏ assign 动作。线程T对变量V的 assign 动作可以认为是和线程T对变量V的store、write动作相关联，必须连续⼀起出现（这条规则要求在⼯作内存中，每次修改V后都必须⽴刻同步回主内存中，⽤于保证其他线程可以看到⾃⼰对变量V所做的修改）。（即 assign store write 连续出现）</p>
</li>
<li><p>假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作 P 是和动作 F 相应的对变量 V 的 read 或 write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G 相应的对变量W的read或write动作。如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执⾏顺序与程序的顺序相同）。</p>
</li>
</ul>
<h3 id="1-3-1-保证可见性"><a href="#1-3-1-保证可见性" class="headerlink" title="1.3.1 保证可见性"></a><font color="#3FBA8B" size="4" face="黑体">1.3.1 保证可见性</font></h3><blockquote>
<p>误解：<br>关于volatile变量的可见性，经常会被开发⼈员误解，认为以下描述成⽴：“volatile变量对所有线程是⽴即可见的，对volatile变量所有的写操作都能⽴刻反应到其他线程之中，换句话说，volatile变量在各个线程中是⼀致 的，所以基于volatile变量的运算在并发下是安全的”。</p>
</blockquote>
<p>这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全 的”这个结论。volatile 变量在各个线程的⼯作内存中不存在⼀致性问题（在各个线程的⼯作内存中，volatile变量也可以存在不⼀致的情况，但由于每次使⽤之前都要先刷新，执⾏引擎看不到不⼀致的情况，因此可以认为不存在⼀致性问题）。</p>
<p>但是 Java ⾥⾯的运算并⾮原⼦操作，导致volatile变量的运算在并发下⼀样是不安全的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * volatile变量自增运算测试</span><br><span class="line"> */</span><br><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    public static volatile int race = 0;</span><br><span class="line"></span><br><span class="line">    public static void increase() &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final int THREADS_COUNT = 20;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Thread[] threads = new Thread[THREADS_COUNT];</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 等待所有累加线程都结束</span><br><span class="line">        while (Thread.activeCount() &gt; 1)</span><br><span class="line">            Thread.yield();</span><br><span class="line"></span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码发起了20个线程，每个线程对 race 变量进⾏10000次⾃增操 作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。读者运⾏完这段代码之后，并不会获得期望的结果，⽽且会发现每次运⾏程 序，输出的结果都不⼀样，都是⼀个⼩于200000的数字，这是为什么呢？</p>
<p>问题就出现在⾃增运算”race++“之中，我们⽤ Javap 反编译这段代码后会得到下列字节码：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz8i1jnpjlj318g0hwtdr.jpg" alt></p>
<p>发现只有⼀⾏代码的increase()⽅法在 Class ⽂件中是 由 4 条字节码指令构成的（ return 指令不是由 race++ 产⽣的，这条指令可以不计算），从字节码层⾯上很容易就分析出并发失败的原因了：当getstatic 指令把 race 的值取到操作栈顶时，volatile关键字保证了race的值在此时是确的，但是在执⾏ iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值加⼤了，⽽在操作栈顶的值就变成了过期的数据，所以 putstatic 指令执⾏后就可能把较⼩的 race 值同步回主内存之中。</p>
<blockquote>
<p>也就是说，volatile 真的只是保证了变量的可见性而已，并没有任何同步的作用，对「变量更改」这个动作，除了「取到正确的数据」步骤外，在更改的过程中也要与其他线程互斥才能保证原子性，volatile 只保证取到了此刻内存中正确的数据。</p>
</blockquote>
<p>而且即使编译出来只有⼀条字节码指令，也并不意味执⾏这条指令就是⼀ 个原⼦操作。⼀条字节码指令在解释执⾏时，解释器将要运⾏许多⾏代码才能实现它的语义，如果是编译执⾏，⼀条字节码指令也可能转化成若⼲条本地机器码指令，此处使⽤-XX:+PrintAssembly参数输出反汇编来分析会更加严谨⼀些，但考虑到阅读的⽅便，并且字节码已经能说明问题，所以此处使⽤字节码来分析。</p>
<p>由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景 中，我们仍然要通过加锁（使⽤synchronized 或java.util.concurrent中的原⼦类来保证原⼦性。</p>
<p>什么时候用 volatile 没问题？即 volatile 的使用场景：</p>
<ul>
<li><p>运算结果并不依赖变量的当前值，或者能够确保只有单⼀的线程修改变量的值。</p>
</li>
<li><p>变量不需要与其他的状态变量共同参与不变约束。</p>
</li>
</ul>
<p>下面这类场景就很适合使⽤volatile变量来控制并发，当shutdown()⽅法被调⽤时，能保证所有线程中执⾏的 doWork() ⽅法都⽴即停下来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">volatile boolean shutdownRequested;</span><br><span class="line"></span><br><span class="line">// 只有单一线程调用 shutdown 方法，改变 volatile 变量的值</span><br><span class="line">public void shutdown()&#123;</span><br><span class="line">    shutdownRequested = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其他线程工作</span><br><span class="line">public void doWord()&#123;</span><br><span class="line">    while(!shutdownRequested)&#123;</span><br><span class="line">        // do stuff</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-2-禁止指令重排序优化"><a href="#1-3-2-禁止指令重排序优化" class="headerlink" title="1.3.2. 禁止指令重排序优化"></a><font color="#3FBA8B" size="4" face="黑体">1.3.2. 禁止指令重排序优化</font></h3><blockquote>
<p>「指令重排序」并不一定都是好事， 有时我们在并发的情况下，需要安全按照代码顺序执行。比如下面我们必须等到配置信息被初始化后再做后续操作。</p>
</blockquote>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fz8i3yt6qhj317k0tm150.jpg" alt></p>
<p>如果定义initialized变量 时没有使⽤volatile修饰，就可能会由于指令重排序的优化，导致位于线程 A中最后⼀句的代码”initialized=true“被提前执⾏（这⾥虽然使⽤ Java 作为伪代码，但所指的重排序优化是机器级的优化操作，提前执⾏是指这句话对应的汇编代码被提前执⾏），这样在线程 B 中使⽤配置信息的代码就可能出现错误，⽽ volatile 关键字则可以避免此类情况的发⽣。</p>
<p>下面用一可实际操作运行的例子分析 volatile 关键字如何禁止指令排序优化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    // 加 volatile 关键字</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    // 对 instance 复制</span><br><span class="line">                    instance = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，这段代码对instance变量赋值部分的代码如下：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fz8i547128j319w0doag4.jpg" alt></p>
<p>关键变化在于有volatile修饰的变量，赋值后（前⾯mov %eax,0x150(%esi)这句便是赋值操作）多执⾏了⼀个“lock addl $0x0,(%esp)”操作，这个操作相当于⼀个「内存屏障」（Memory Barrier 或Memory Fence，指重排序时不能把后⾯的指令重排序到内存屏障之前的位置），只有⼀个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同⼀块内存，且其中有⼀个在观测另⼀个，就需要内存屏障 来保证⼀致性了。</p>
<p>这句指令中的“addl $0x0,(%esp)”（把 ESP 寄存器的值加 0）显然是⼀个空操作（采⽤这个空操作⽽不是空操作指令 nop 是因为 IA32 ⼿册规定 lock 前缀不允许配合 nop 指令使⽤），关键在于 lock 前缀，查询 IA32⼿册，它的作⽤是使得本 CPU 的 Cache 写⼊了内存，该写⼊动作也会引起别的CPU或者别的内核⽆效化（Invalidate）其Cache，这种操作相当于对 Cache 中的变量做了⼀次前⾯介绍Java内存模式中所说的“store和write”操作 。所以通过这样⼀个空操作，可让前⾯volatile变量的修改对其他 CPU ⽴即可见。</p>
<p>那为何说它禁⽌指令重排序呢？从硬件架构上讲，指令重排序是指 CPU 采⽤了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。但并不是说指令任意重排，CPU 需要能正确处理指令依赖情况以保障程序能得出正确的执⾏结果。譬如指令 1 把地址A中的值加 10，指令 2 把地址 A 中的值乘以 2，指令 3 把地址 B 中的值减去3，这时指令 1 和指令 2 是 有依赖的，它们之间的顺序不能重排——(A+10)<em>2与 (A</em>2+10)显然不相 等，但指令 3 可以重排到指令1、2之前或者中间，只要保证CPU执⾏后⾯依赖到A、B值的操作时能获取到正确的A和B值即可。</p>
<p>所以在本内CPU中， 重排序看起来依然是有序的。因此，lock addl $0x0, (%esp)指令把修改同步到内存时，意味着所有之前的操作都已经执⾏完成，这样便形成了“指令重排序⽆法越过内存屏障”的效果。</p>
<blockquote>
<p>By Louis：即 lock addl $0x0, (%esp) 指令要将修改同步到内存，该指令后的操作与之存在某种「依赖场景」：必须等到它把修改同步到内存再执行，虚拟机能够正确处理这种情况，因此理解为 volatile 会禁止对指令重排序。</p>
</blockquote>
<h3 id="1-3-3-用-volatile-的意义"><a href="#1-3-3-用-volatile-的意义" class="headerlink" title="1.3.3 用 volatile 的意义"></a><font color="#3FBA8B" size="4" face="黑体">1.3.3 用 volatile 的意义</font></h3><p>解决了volatile 的语义问题，再来看看在众多保障并发安全的⼯具中选⽤ volatile 的意义——它能让我们的代码⽐使⽤其他的同步⼯具更快吗？</p>
<p>在某些情况下，volatile 的同步机制的性能确实要优于锁（使⽤synchronized关键字或java.util.concurrent包⾥⾯的锁），但是由于虚拟机对锁实⾏的许多消除和优化，使得我们很难量化地认为 volatile 就会⽐synchronized快多少。</p>
<p>如果让volatile⾃⼰与⾃⼰⽐较，那可以确定⼀个原则：volatile 变量读操作的性能消耗与普通变量⼏乎没有什么差别，但是写操作则可能会慢⼀些， 因为它需要在本地代码中插⼊许多内存屏障指令来保证处理器不发⽣乱序执⾏。</p>
<blockquote>
<p>即便如此，⼤多数场景下 volatile 的总开销仍然要⽐锁低，我们在volatile与锁之中选择的唯⼀依据仅仅是volatile的语义能否满⾜使⽤场景的需求。</p>
</blockquote>
<h2 id="1-4-对于-long-和-double-型变量的特殊规则"><a href="#1-4-对于-long-和-double-型变量的特殊规则" class="headerlink" title="1.4 对于 long 和 double 型变量的特殊规则"></a><font color="#3FBA8B" size="5" face="黑体">1.4 对于 long 和 double 型变量的特殊规则</font></h2><p>Java内存模型要求lock、unlock、read、load、assign、use、store、write 这8个操作都具有原⼦性，但是对于「64位的数据类型」（long和double），在 模型中特别定义了⼀条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为「两次32位的操作」来进⾏，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原⼦性，这点就是所谓的long和double的「⾮原⼦性协定」（Nonatomic Treatment ofdouble and long Variables）。</p>
<p>如果有多个线程共享⼀个并未声明为volatile的long或double类型的变量，并且同时对它们进⾏读取和修改操作，那么某些线程可能会读取到⼀个既⾮原值，也不是其他线程修改值的代表了“半个变量”的数值。</p>
<p>不过这种读取到“半个变量”的情况⾮常罕见（在⽬前商⽤Java虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原⼦操作，但允许虚拟机选择把这些操作实现为具有原⼦性的操作，⽽且还“强烈建议”虚拟机这样实现。在实际开发中，⽬前各种平台 下的商⽤虚拟机⼏乎都选择把64位数据的读写操作作为原⼦操作来对待， 因此我们在编写代码时⼀般不需要把⽤到的 long 和double变量专门声明为 volatile。</p>
<h2 id="1-5-原子性、可见性、有序性"><a href="#1-5-原子性、可见性、有序性" class="headerlink" title="1.5 原子性、可见性、有序性"></a><font color="#3FBA8B" size="5" face="黑体">1.5 原子性、可见性、有序性</font></h2><p>介绍完Java内存模型的相关操作和规则，我们再整体回顾⼀下这个模型的特征。Java内存模型是围绕着在并发过程中如何处理原⼦性、可见性和有序性这3个特征来建⽴的。</p>
<ul>
<li><p>原子性：不赘述，需要注意的是，在synchronized块之间的操作也具备原子性。</p>
</li>
<li><p>可见性：指当⼀个线程修改了共享变量的值， 其他线程能够⽴即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的⽅式来实现可见性的，volatile的特殊规则保证了新值能⽴即同步到主内 存，以及每次使⽤前⽴即从主内存刷新。除了volatile之外，Java还有两个关键字能实现可见性，即synchronized 和final。同步块（synchronized块）的可见性是由“对⼀个变量执⾏unlock操作之前，必须先把 此变量同步回主内存中（执⾏store、write操作）”这条规则获得的，⽽final 关键字的可见性是指：被final修饰的字段在构造器中⼀旦初始化完成，并 且构造器没有把”this”的引⽤传递出去（this引⽤逃逸是⼀件很危险的事 情，其他线程有可能通过这个引⽤访问到“初始化了⼀半”的对象），那在 其他线程中就能看见final字段的值。</p>
</li>
<li><p>有序性：Java程序中天然的有序性可以总结为⼀句话：如果在本线程内观察，所有的操作都是有序的；如果在⼀个线程中观察另⼀个线程， 所有的操作都是⽆序的。前半句是指“线程内表现为串⾏的语义”（WithinThread As-If-Serial Semantics），后半句是指“指令重排序”现象和“⼯作内存与主内存同步延迟”现象。Java语⾔提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本⾝就包含了禁⽌指令重排序的语义，⽽ synchronized则是由“⼀个变量在同⼀个时刻只允许⼀条线程对其进⾏lock 作”这条规则获得的，这条规则决定了持有同⼀个锁的两个同步块只能串⾏地进⼊。</p>
</li>
</ul>
<p><strong>细心的读者可以发现，synchronized关键字在需要这三种特性的时候都可以作为其中一种解决方案，这也导致了synchronized的滥用。</strong></p>
<h2 id="1-6-先行发生原则"><a href="#1-6-先行发生原则" class="headerlink" title="1.6 先行发生原则"></a><font color="#3FBA8B" size="5" face="黑体">1.6 先行发生原则</font></h2><p>如果Java内存模型中所有的有序性都仅仅靠volatile和synchronized来完 成，那么有⼀些操作将会变得很烦琐，但是我们在编写Java并发代码的时 候并没有感觉到这⼀点，这是因为Java语⾔中有⼀个“先⾏发⽣”（happensbefore）的原则。</p>
<blockquote>
<p>「先⾏发⽣」是Java内存模型中定义的两项操作之间的偏序关系（即优先顺序），如果说操作 A 先⾏发⽣于操作 B，其实就是说在发⽣操作 B 之前，操作 A 产⽣的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调⽤了⽅法等。</p>
</blockquote>
<p>先行发生原则，是判断数据是否存在竞争、线程 是否安全的主要依据，依靠这个原则，我们可以通过⼏条规则⼀揽⼦地解 决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 1; // 在线程 A 中执行</span><br><span class="line">j = i; // B</span><br><span class="line">i = 2; // C</span><br></pre></td></tr></table></figure>
<p>下面是 Java 内存模型下一些天然的 「先行发生」关系，这些先⾏发⽣关系⽆须任何同步器协助就已经存在，可以在编码中直接使⽤。如果两个操作之间的关系不在此列，并且⽆法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进⾏重排序。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fz8ihefrqqj30zq0u01kx.jpg" alt></p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private int value = 0;</span><br><span class="line">public void setValue(int value)&#123;</span><br><span class="line">    this.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getValue()&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不满足上述任一个先行发生原则，操作不慎线程安全的。</p>
<p>可以把 getter/setter 方法都定义为「synchronized」，这样就可以套用「管程锁规则」，要么把 value 定义为 volatile 变量，由于 setter 方法对 value 的修改不依赖于 value 值，满足 volatile 关键字使用场景，可以套用「volatile」变量的规则。</p>
<p>⼀个操作“时间上的先发⽣”不代表这个操作会是“先⾏发⽣”，反之亦然，先行发生也不代表时间上先发生。时间先后顺序与先⾏发⽣原则之间基本没有太⼤的关系，所以我们衡量并发安全问题的时候不要受到 时间顺序的⼲扰，⼀切必须以先⾏发⽣原则为准。</p>
<h1 id="2-Java与线程"><a href="#2-Java与线程" class="headerlink" title="2. Java与线程"></a><font color="#3FBA8B" size="6" face="黑体">2. Java与线程</font></h1><h2 id="2-1-线程的实现"><a href="#2-1-线程的实现" class="headerlink" title="2.1 线程的实现"></a><font color="#3FBA8B" size="face=" 黑体"">2.1 线程的实现</font></h2><blockquote>
<p>线程是CPU调度的基本单位</p>
</blockquote>
<p>实现线程主要有3种方式：</p>
<ul>
<li>使用内核线程实现</li>
<li>使用用户线程实现</li>
<li>使用用户线程加轻量级进程混合实现</li>
</ul>
<h3 id="2-1-1-使用内核线程实现"><a href="#2-1-1-使用内核线程实现" class="headerlink" title="2.1.1 使用内核线程实现"></a><font color="#3FBA8B" size="4" face="黑体">2.1.1 使用内核线程实现</font></h3><p>内核线程（Kernel-Level Thread，KLT）就是由操作系统内核支持的线程，这种线程由内核来完成线程切换。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口—轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程，每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型。</p>
<p>轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是优先的。</p>
<h3 id="2-1-2-使用用户线程实现"><a href="#2-1-2-使用用户线程实现" class="headerlink" title="2.1.2 使用用户线程实现"></a><font color="#3FBA8B" size="4" face="黑体">2.1.2 使用用户线程实现</font></h3><p>从广义上来讲，一个线程只要不是内核线程就可以认为是用户线程。因此，从这个定义来讲，轻量级进程也属于用户线程，但轻量级进程的实现始终是建立在内核之上的，许多操作都要进行系统调用，效率会受到限制。</p>
<p>而狭义上的用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。</p>
<p>进程与用户线程是1:N的对应关系。</p>
<blockquote>
<p>用户线程有许多弊端，诸如阻塞如何处理、多处理器系统中如何将线程映射到其他处理器上，这样的问题解决起来将异常困难，甚至不可完成。Java、Ruby都曾使用过用户线程，最终又放弃它。</p>
</blockquote>
<h3 id="2-1-3-使用用户线程加轻量级进程混合实现"><a href="#2-1-3-使用用户线程加轻量级进程混合实现" class="headerlink" title="2.1.3 使用用户线程加轻量级进程混合实现"></a><font color="#3FBA8B" size="4" face="黑体">2.1.3 使用用户线程加轻量级进程混合实现</font></h3><p>这种模式下用户线程与轻量级进程的数量比是不定的，即为N:M的关系。</p>
<h3 id="2-1-4-Java线程的实现"><a href="#2-1-4-Java线程的实现" class="headerlink" title="2.1.4 Java线程的实现"></a><font color="#3FBA8B" size="4" face="黑体">2.1.4 Java线程的实现</font></h3><p>Java线程在不同平台上的实现不一样，但对Java编码和程序运行来说，这些差异都是透明的。</p>
<h2 id="2-2-Java线程调度"><a href="#2-2-Java线程调度" class="headerlink" title="2.2 Java线程调度"></a><font color="#3FBA8B" size="face=" 黑体"">2.2 Java线程调度</font></h2><p>主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p>
<h3 id="2-2-1-协同式线程调度"><a href="#2-2-1-协同式线程调度" class="headerlink" title="2.2.1 协同式线程调度"></a><font color="#3FBA8B" size="4" face="黑体">2.2.1 协同式线程调度</font></h3><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。</p>
<ul>
<li>优点： 实现简单，且切换操作对线程自己是可知的，没啥线程同步问题。</li>
<li>缺点： 线程执行时间不可控制，如果一个线程有问题，可能一直阻塞在那里。</li>
</ul>
<h3 id="2-2-2-抢占式线程调度"><a href="#2-2-2-抢占式线程调度" class="headerlink" title="2.2.2 抢占式线程调度"></a><font color="#3FBA8B" size="4" face="黑体">2.2.2 抢占式线程调度</font></h3><p>抢占式调度，每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。</p>
<blockquote>
<p>Java中，Thread.yield()可以让出执行时间，但无法获取执行时间。</p>
</blockquote>
<h3 id="2-2-3-线程优先级"><a href="#2-2-3-线程优先级" class="headerlink" title="2.2.3 线程优先级"></a><font color="#3FBA8B" size="4" face="黑体">2.2.3 线程优先级</font></h3><p>如果希望系统能给某些线程多分配一些时间，给一些线程少分配一些时间，可以通过设置线程优先级来完成。<br>Java语言一共10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两线程同时处于ready状态时，优先级越高的线程越容易被系统选择执行。但优先级并不是很靠谱，因为Java线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统。</p>
<h2 id="2-3线程的状态转换"><a href="#2-3线程的状态转换" class="headerlink" title="2.3线程的状态转换"></a><font color="#3FBA8B" size="face=" 黑体"">2.3线程的状态转换</font></h2><p>Java定义了5种线程状态，在任意一个点一个线程只能有且只有其中一种状态。无限等待和等待可以算在一起。所以共五种。（好像也有人喜欢说是六种）</p>
<ul>
<li>新建(New)：创建后尚未启动的线程。</li>
<li>运行(Runnable)：Runnable包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能等待CPU为它分配执行时间。线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。</li>
<li>无限期等待(Waiting)：该状态下线程不会被分配CPU执行时间，要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ol>
<li>Timeout的object.wait()方</li>
<li>Thread.join()方法</li>
<li>LockSupport.park()方法。</li>
</ol>
</li>
<li>限期等待(Timed Waiting)：不会被分配CPU执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ol>
<li>如Thread.sleep()</li>
<li>设置了Timeout的object.wait()</li>
<li>设置了Timeout的thread.join()</li>
<li>LockSupport.parkNanos()以及</li>
<li>LockSupport.parkUntil()方法。</li>
</ol>
</li>
<li>阻塞（Blocked）:线程被阻塞了。与等待状态的区别是：阻塞在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而等待则在等待一段时间，或唤醒动作的发生。在等待进入同步区域时，线程将进入这种状态。</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fz8ks8p703j30cs082gmg.jpg" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/线程/" rel="tag"># 线程</a>
          
            <a href="/tags/volatile/" rel="tag"># volatile</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/15/深入理解Java虚拟机读书笔记第7章-虚拟机类加载机制/" rel="next" title="Java虚拟机类加载机制">
                <i class="fa fa-chevron-left"></i> Java虚拟机类加载机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/17/深入理解Java虚拟机读书笔记第13章-线程安全与锁优化/" rel="prev" title="Java线程安全与锁优化">
                Java线程安全与锁优化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">immrwk</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Java-内存模型"><span class="nav-number">1.</span> <span class="nav-text">1. Java 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-主内存与工作内存"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 主内存与工作内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-内存间交互操作"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 内存间交互操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-对-volatile-型变量的特殊规则"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 对 volatile 型变量的特殊规则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-保证可见性"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 保证可见性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-禁止指令重排序优化"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. 禁止指令重排序优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-用-volatile-的意义"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 用 volatile 的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-对于-long-和-double-型变量的特殊规则"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 对于 long 和 double 型变量的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-原子性、可见性、有序性"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 原子性、可见性、有序性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-先行发生原则"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 先行发生原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Java与线程"><span class="nav-number">2.</span> <span class="nav-text">2. Java与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-线程的实现"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 线程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-使用内核线程实现"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 使用内核线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-使用用户线程实现"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 使用用户线程实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-使用用户线程加轻量级进程混合实现"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 使用用户线程加轻量级进程混合实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-Java线程的实现"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 Java线程的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Java线程调度"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Java线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-协同式线程调度"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 协同式线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-抢占式线程调度"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 抢占式线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-线程优先级"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 线程优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3线程的状态转换"><span class="nav-number">2.3.</span> <span class="nav-text">2.3线程的状态转换</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">immrwk</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
